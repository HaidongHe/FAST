!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2015  National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!**********************************************************************************************************************************
MODULE BeamDyn_IO

   USE BeamDyn_Types
   USE BeamDyn_Subs
   USE NWTC_Library

   IMPLICIT NONE

   TYPE(ProgDesc), PARAMETER:: BeamDyn_Ver = ProgDesc('BeamDyn', 'v1.00.00','25-July-2015')


! ===================================================================================================
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 25-Jul-2015 12:42:16.


     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1


     ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time: 

   INTEGER(IntKi), PARAMETER      :: Time      =   0


     ! Reaction Loads:

   INTEGER(IntKi), PARAMETER      :: RootFxr   =   1
   INTEGER(IntKi), PARAMETER      :: RootFyr   =   2
   INTEGER(IntKi), PARAMETER      :: RootFzr   =   3
   INTEGER(IntKi), PARAMETER      :: RootMxr   =   4
   INTEGER(IntKi), PARAMETER      :: RootMyr   =   5
   INTEGER(IntKi), PARAMETER      :: RootMzr   =   6


     ! Tip Motions:

   INTEGER(IntKi), PARAMETER      :: TipTDxr   =   7
   INTEGER(IntKi), PARAMETER      :: TipTDyr   =   8
   INTEGER(IntKi), PARAMETER      :: TipTDzr   =   9
   INTEGER(IntKi), PARAMETER      :: TipRDxr   =  10
   INTEGER(IntKi), PARAMETER      :: TipRDyr   =  11
   INTEGER(IntKi), PARAMETER      :: TipRDzr   =  12
   INTEGER(IntKi), PARAMETER      :: TipTVXg   =  13
   INTEGER(IntKi), PARAMETER      :: TipTVYg   =  14
   INTEGER(IntKi), PARAMETER      :: TipTVZg   =  15
   INTEGER(IntKi), PARAMETER      :: TipRVXg   =  16
   INTEGER(IntKi), PARAMETER      :: TipRVYg   =  17
   INTEGER(IntKi), PARAMETER      :: TipRVZg   =  18
   INTEGER(IntKi), PARAMETER      :: TipTAXg   =  19
   INTEGER(IntKi), PARAMETER      :: TipTAYg   =  20
   INTEGER(IntKi), PARAMETER      :: TipTAZg   =  21
   INTEGER(IntKi), PARAMETER      :: TipRAXg   =  22
   INTEGER(IntKi), PARAMETER      :: TipRAYg   =  23
   INTEGER(IntKi), PARAMETER      :: TipRAZg   =  24


     ! Sectional Loads:

   INTEGER(IntKi), PARAMETER      :: N1Fxl     =  25
   INTEGER(IntKi), PARAMETER      :: N1Fyl     =  26
   INTEGER(IntKi), PARAMETER      :: N1Fzl     =  27
   INTEGER(IntKi), PARAMETER      :: N2Fxl     =  28
   INTEGER(IntKi), PARAMETER      :: N2Fyl     =  29
   INTEGER(IntKi), PARAMETER      :: N2Fzl     =  30
   INTEGER(IntKi), PARAMETER      :: N3Fxl     =  31
   INTEGER(IntKi), PARAMETER      :: N3Fyl     =  32
   INTEGER(IntKi), PARAMETER      :: N3Fzl     =  33
   INTEGER(IntKi), PARAMETER      :: N4Fxl     =  34
   INTEGER(IntKi), PARAMETER      :: N4Fyl     =  35
   INTEGER(IntKi), PARAMETER      :: N4Fzl     =  36
   INTEGER(IntKi), PARAMETER      :: N5Fxl     =  37
   INTEGER(IntKi), PARAMETER      :: N5Fyl     =  38
   INTEGER(IntKi), PARAMETER      :: N5Fzl     =  39
   INTEGER(IntKi), PARAMETER      :: N6Fxl     =  40
   INTEGER(IntKi), PARAMETER      :: N6Fyl     =  41
   INTEGER(IntKi), PARAMETER      :: N6Fzl     =  42
   INTEGER(IntKi), PARAMETER      :: N7Fxl     =  43
   INTEGER(IntKi), PARAMETER      :: N7Fyl     =  44
   INTEGER(IntKi), PARAMETER      :: N7Fzl     =  45
   INTEGER(IntKi), PARAMETER      :: N8Fxl     =  46
   INTEGER(IntKi), PARAMETER      :: N8Fyl     =  47
   INTEGER(IntKi), PARAMETER      :: N8Fzl     =  48
   INTEGER(IntKi), PARAMETER      :: N9Fxl     =  49
   INTEGER(IntKi), PARAMETER      :: N9Fyl     =  50
   INTEGER(IntKi), PARAMETER      :: N9Fzl     =  51
   INTEGER(IntKi), PARAMETER      :: N1Mxl     =  52
   INTEGER(IntKi), PARAMETER      :: N1Myl     =  53
   INTEGER(IntKi), PARAMETER      :: N1Mzl     =  54
   INTEGER(IntKi), PARAMETER      :: N2Mxl     =  55
   INTEGER(IntKi), PARAMETER      :: N2Myl     =  56
   INTEGER(IntKi), PARAMETER      :: N2Mzl     =  57
   INTEGER(IntKi), PARAMETER      :: N3Mxl     =  58
   INTEGER(IntKi), PARAMETER      :: N3Myl     =  59
   INTEGER(IntKi), PARAMETER      :: N3Mzl     =  60
   INTEGER(IntKi), PARAMETER      :: N4Mxl     =  61
   INTEGER(IntKi), PARAMETER      :: N4Myl     =  62
   INTEGER(IntKi), PARAMETER      :: N4Mzl     =  63
   INTEGER(IntKi), PARAMETER      :: N5Mxl     =  64
   INTEGER(IntKi), PARAMETER      :: N5Myl     =  65
   INTEGER(IntKi), PARAMETER      :: N5Mzl     =  66
   INTEGER(IntKi), PARAMETER      :: N6Mxl     =  67
   INTEGER(IntKi), PARAMETER      :: N6Myl     =  68
   INTEGER(IntKi), PARAMETER      :: N6Mzl     =  69
   INTEGER(IntKi), PARAMETER      :: N7Mxl     =  70
   INTEGER(IntKi), PARAMETER      :: N7Myl     =  71
   INTEGER(IntKi), PARAMETER      :: N7Mzl     =  72
   INTEGER(IntKi), PARAMETER      :: N8Mxl     =  73
   INTEGER(IntKi), PARAMETER      :: N8Myl     =  74
   INTEGER(IntKi), PARAMETER      :: N8Mzl     =  75
   INTEGER(IntKi), PARAMETER      :: N9Mxl     =  76
   INTEGER(IntKi), PARAMETER      :: N9Myl     =  77
   INTEGER(IntKi), PARAMETER      :: N9Mzl     =  78


     ! Sectional Motions:

   INTEGER(IntKi), PARAMETER      :: N1TDxr    =  79
   INTEGER(IntKi), PARAMETER      :: N1TDyr    =  80
   INTEGER(IntKi), PARAMETER      :: N1TDzr    =  81
   INTEGER(IntKi), PARAMETER      :: N2TDxr    =  82
   INTEGER(IntKi), PARAMETER      :: N2TDyr    =  83
   INTEGER(IntKi), PARAMETER      :: N2TDzr    =  84
   INTEGER(IntKi), PARAMETER      :: N3TDxr    =  85
   INTEGER(IntKi), PARAMETER      :: N3TDyr    =  86
   INTEGER(IntKi), PARAMETER      :: N3TDzr    =  87
   INTEGER(IntKi), PARAMETER      :: N4TDxr    =  88
   INTEGER(IntKi), PARAMETER      :: N4TDyr    =  89
   INTEGER(IntKi), PARAMETER      :: N4TDzr    =  90
   INTEGER(IntKi), PARAMETER      :: N5TDxr    =  91
   INTEGER(IntKi), PARAMETER      :: N5TDyr    =  92
   INTEGER(IntKi), PARAMETER      :: N5TDzr    =  93
   INTEGER(IntKi), PARAMETER      :: N6TDxr    =  94
   INTEGER(IntKi), PARAMETER      :: N6TDyr    =  95
   INTEGER(IntKi), PARAMETER      :: N6TDzr    =  96
   INTEGER(IntKi), PARAMETER      :: N7TDxr    =  97
   INTEGER(IntKi), PARAMETER      :: N7TDyr    =  98
   INTEGER(IntKi), PARAMETER      :: N7TDzr    =  99
   INTEGER(IntKi), PARAMETER      :: N8TDxr    = 100
   INTEGER(IntKi), PARAMETER      :: N8TDyr    = 101
   INTEGER(IntKi), PARAMETER      :: N8TDzr    = 102
   INTEGER(IntKi), PARAMETER      :: N9TDxr    = 103
   INTEGER(IntKi), PARAMETER      :: N9TDyr    = 104
   INTEGER(IntKi), PARAMETER      :: N9TDzr    = 105
   INTEGER(IntKi), PARAMETER      :: N1RDxr    = 106
   INTEGER(IntKi), PARAMETER      :: N1RDyr    = 107
   INTEGER(IntKi), PARAMETER      :: N1RDzr    = 108
   INTEGER(IntKi), PARAMETER      :: N2RDxr    = 109
   INTEGER(IntKi), PARAMETER      :: N2RDyr    = 110
   INTEGER(IntKi), PARAMETER      :: N2RDzr    = 111
   INTEGER(IntKi), PARAMETER      :: N3RDxr    = 112
   INTEGER(IntKi), PARAMETER      :: N3RDyr    = 113
   INTEGER(IntKi), PARAMETER      :: N3RDzr    = 114
   INTEGER(IntKi), PARAMETER      :: N4RDxr    = 115
   INTEGER(IntKi), PARAMETER      :: N4RDyr    = 116
   INTEGER(IntKi), PARAMETER      :: N4RDzr    = 117
   INTEGER(IntKi), PARAMETER      :: N5RDxr    = 118
   INTEGER(IntKi), PARAMETER      :: N5RDyr    = 119
   INTEGER(IntKi), PARAMETER      :: N5RDzr    = 120
   INTEGER(IntKi), PARAMETER      :: N6RDxr    = 121
   INTEGER(IntKi), PARAMETER      :: N6RDyr    = 122
   INTEGER(IntKi), PARAMETER      :: N6RDzr    = 123
   INTEGER(IntKi), PARAMETER      :: N7RDxr    = 124
   INTEGER(IntKi), PARAMETER      :: N7RDyr    = 125
   INTEGER(IntKi), PARAMETER      :: N7RDzr    = 126
   INTEGER(IntKi), PARAMETER      :: N8RDxr    = 127
   INTEGER(IntKi), PARAMETER      :: N8RDyr    = 128
   INTEGER(IntKi), PARAMETER      :: N8RDzr    = 129
   INTEGER(IntKi), PARAMETER      :: N9RDxr    = 130
   INTEGER(IntKi), PARAMETER      :: N9RDyr    = 131
   INTEGER(IntKi), PARAMETER      :: N9RDzr    = 132
   INTEGER(IntKi), PARAMETER      :: N1TVXg    = 133
   INTEGER(IntKi), PARAMETER      :: N1TVYg    = 134
   INTEGER(IntKi), PARAMETER      :: N1TVZg    = 135
   INTEGER(IntKi), PARAMETER      :: N2TVXg    = 136
   INTEGER(IntKi), PARAMETER      :: N2TVYg    = 137
   INTEGER(IntKi), PARAMETER      :: N2TVZg    = 138
   INTEGER(IntKi), PARAMETER      :: N3TVXg    = 139
   INTEGER(IntKi), PARAMETER      :: N3TVYg    = 140
   INTEGER(IntKi), PARAMETER      :: N3TVZg    = 141
   INTEGER(IntKi), PARAMETER      :: N4TVXg    = 142
   INTEGER(IntKi), PARAMETER      :: N4TVYg    = 143
   INTEGER(IntKi), PARAMETER      :: N4TVZg    = 144
   INTEGER(IntKi), PARAMETER      :: N5TVXg    = 145
   INTEGER(IntKi), PARAMETER      :: N5TVYg    = 146
   INTEGER(IntKi), PARAMETER      :: N5TVZg    = 147
   INTEGER(IntKi), PARAMETER      :: N6TVXg    = 148
   INTEGER(IntKi), PARAMETER      :: N6TVYg    = 149
   INTEGER(IntKi), PARAMETER      :: N6TVZg    = 150
   INTEGER(IntKi), PARAMETER      :: N7TVXg    = 151
   INTEGER(IntKi), PARAMETER      :: N7TVYg    = 152
   INTEGER(IntKi), PARAMETER      :: N7TVZg    = 153
   INTEGER(IntKi), PARAMETER      :: N8TVXg    = 154
   INTEGER(IntKi), PARAMETER      :: N8TVYg    = 155
   INTEGER(IntKi), PARAMETER      :: N8TVZg    = 156
   INTEGER(IntKi), PARAMETER      :: N9TVXg    = 157
   INTEGER(IntKi), PARAMETER      :: N9TVYg    = 158
   INTEGER(IntKi), PARAMETER      :: N9TVZg    = 159
   INTEGER(IntKi), PARAMETER      :: N1RVXg    = 160
   INTEGER(IntKi), PARAMETER      :: N1RVYg    = 161
   INTEGER(IntKi), PARAMETER      :: N1RVZg    = 162
   INTEGER(IntKi), PARAMETER      :: N2RVXg    = 163
   INTEGER(IntKi), PARAMETER      :: N2RVYg    = 164
   INTEGER(IntKi), PARAMETER      :: N2RVZg    = 165
   INTEGER(IntKi), PARAMETER      :: N3RVXg    = 166
   INTEGER(IntKi), PARAMETER      :: N3RVYg    = 167
   INTEGER(IntKi), PARAMETER      :: N3RVZg    = 168
   INTEGER(IntKi), PARAMETER      :: N4RVXg    = 169
   INTEGER(IntKi), PARAMETER      :: N4RVYg    = 170
   INTEGER(IntKi), PARAMETER      :: N4RVZg    = 171
   INTEGER(IntKi), PARAMETER      :: N5RVXg    = 172
   INTEGER(IntKi), PARAMETER      :: N5RVYg    = 173
   INTEGER(IntKi), PARAMETER      :: N5RVZg    = 174
   INTEGER(IntKi), PARAMETER      :: N6RVXg    = 175
   INTEGER(IntKi), PARAMETER      :: N6RVYg    = 176
   INTEGER(IntKi), PARAMETER      :: N6RVZg    = 177
   INTEGER(IntKi), PARAMETER      :: N7RVXg    = 178
   INTEGER(IntKi), PARAMETER      :: N7RVYg    = 179
   INTEGER(IntKi), PARAMETER      :: N7RVZg    = 180
   INTEGER(IntKi), PARAMETER      :: N8RVXg    = 181
   INTEGER(IntKi), PARAMETER      :: N8RVYg    = 182
   INTEGER(IntKi), PARAMETER      :: N8RVZg    = 183
   INTEGER(IntKi), PARAMETER      :: N9RVXg    = 184
   INTEGER(IntKi), PARAMETER      :: N9RVYg    = 185
   INTEGER(IntKi), PARAMETER      :: N9RVZg    = 186
   INTEGER(IntKi), PARAMETER      :: N1TAXg    = 187
   INTEGER(IntKi), PARAMETER      :: N1TAYg    = 188
   INTEGER(IntKi), PARAMETER      :: N1TAZg    = 189
   INTEGER(IntKi), PARAMETER      :: N2TAXg    = 190
   INTEGER(IntKi), PARAMETER      :: N2TAYg    = 191
   INTEGER(IntKi), PARAMETER      :: N2TAZg    = 192
   INTEGER(IntKi), PARAMETER      :: N3TAXg    = 193
   INTEGER(IntKi), PARAMETER      :: N3TAYg    = 194
   INTEGER(IntKi), PARAMETER      :: N3TAZg    = 195
   INTEGER(IntKi), PARAMETER      :: N4TAXg    = 196
   INTEGER(IntKi), PARAMETER      :: N4TAYg    = 197
   INTEGER(IntKi), PARAMETER      :: N4TAZg    = 198
   INTEGER(IntKi), PARAMETER      :: N5TAXg    = 199
   INTEGER(IntKi), PARAMETER      :: N5TAYg    = 200
   INTEGER(IntKi), PARAMETER      :: N5TAZg    = 201
   INTEGER(IntKi), PARAMETER      :: N6TAXg    = 202
   INTEGER(IntKi), PARAMETER      :: N6TAYg    = 203
   INTEGER(IntKi), PARAMETER      :: N6TAZg    = 204
   INTEGER(IntKi), PARAMETER      :: N7TAXg    = 205
   INTEGER(IntKi), PARAMETER      :: N7TAYg    = 206
   INTEGER(IntKi), PARAMETER      :: N7TAZg    = 207
   INTEGER(IntKi), PARAMETER      :: N8TAXg    = 208
   INTEGER(IntKi), PARAMETER      :: N8TAYg    = 209
   INTEGER(IntKi), PARAMETER      :: N8TAZg    = 210
   INTEGER(IntKi), PARAMETER      :: N9TAXg    = 211
   INTEGER(IntKi), PARAMETER      :: N9TAYg    = 212
   INTEGER(IntKi), PARAMETER      :: N9TAZg    = 213
   INTEGER(IntKi), PARAMETER      :: N1RAXg    = 214
   INTEGER(IntKi), PARAMETER      :: N1RAYg    = 215
   INTEGER(IntKi), PARAMETER      :: N1RAZg    = 216
   INTEGER(IntKi), PARAMETER      :: N2RAXg    = 217
   INTEGER(IntKi), PARAMETER      :: N2RAYg    = 218
   INTEGER(IntKi), PARAMETER      :: N2RAZg    = 219
   INTEGER(IntKi), PARAMETER      :: N3RAXg    = 220
   INTEGER(IntKi), PARAMETER      :: N3RAYg    = 221
   INTEGER(IntKi), PARAMETER      :: N3RAZg    = 222
   INTEGER(IntKi), PARAMETER      :: N4RAXg    = 223
   INTEGER(IntKi), PARAMETER      :: N4RAYg    = 224
   INTEGER(IntKi), PARAMETER      :: N4RAZg    = 225
   INTEGER(IntKi), PARAMETER      :: N5RAXg    = 226
   INTEGER(IntKi), PARAMETER      :: N5RAYg    = 227
   INTEGER(IntKi), PARAMETER      :: N5RAZg    = 228
   INTEGER(IntKi), PARAMETER      :: N6RAXg    = 229
   INTEGER(IntKi), PARAMETER      :: N6RAYg    = 230
   INTEGER(IntKi), PARAMETER      :: N6RAZg    = 231
   INTEGER(IntKi), PARAMETER      :: N7RAXg    = 232
   INTEGER(IntKi), PARAMETER      :: N7RAYg    = 233
   INTEGER(IntKi), PARAMETER      :: N7RAZg    = 234
   INTEGER(IntKi), PARAMETER      :: N8RAXg    = 235
   INTEGER(IntKi), PARAMETER      :: N8RAYg    = 236
   INTEGER(IntKi), PARAMETER      :: N8RAZg    = 237
   INTEGER(IntKi), PARAMETER      :: N9RAXg    = 238
   INTEGER(IntKi), PARAMETER      :: N9RAYg    = 239
   INTEGER(IntKi), PARAMETER      :: N9RAZg    = 240


     ! Applied Loads:

   INTEGER(IntKi), PARAMETER      :: N1PFxl    = 241
   INTEGER(IntKi), PARAMETER      :: N1PFyl    = 242
   INTEGER(IntKi), PARAMETER      :: N1PFzl    = 243
   INTEGER(IntKi), PARAMETER      :: N2PFxl    = 244
   INTEGER(IntKi), PARAMETER      :: N2PFyl    = 245
   INTEGER(IntKi), PARAMETER      :: N2PFzl    = 246
   INTEGER(IntKi), PARAMETER      :: N3PFxl    = 247
   INTEGER(IntKi), PARAMETER      :: N3PFyl    = 248
   INTEGER(IntKi), PARAMETER      :: N3PFzl    = 249
   INTEGER(IntKi), PARAMETER      :: N4PFxl    = 250
   INTEGER(IntKi), PARAMETER      :: N4PFyl    = 251
   INTEGER(IntKi), PARAMETER      :: N4PFzl    = 252
   INTEGER(IntKi), PARAMETER      :: N5PFxl    = 253
   INTEGER(IntKi), PARAMETER      :: N5PFyl    = 254
   INTEGER(IntKi), PARAMETER      :: N5PFzl    = 255
   INTEGER(IntKi), PARAMETER      :: N6PFxl    = 256
   INTEGER(IntKi), PARAMETER      :: N6PFyl    = 257
   INTEGER(IntKi), PARAMETER      :: N6PFzl    = 258
   INTEGER(IntKi), PARAMETER      :: N7PFxl    = 259
   INTEGER(IntKi), PARAMETER      :: N7PFyl    = 260
   INTEGER(IntKi), PARAMETER      :: N7PFzl    = 261
   INTEGER(IntKi), PARAMETER      :: N8PFxl    = 262
   INTEGER(IntKi), PARAMETER      :: N8PFyl    = 263
   INTEGER(IntKi), PARAMETER      :: N8PFzl    = 264
   INTEGER(IntKi), PARAMETER      :: N9PFxl    = 265
   INTEGER(IntKi), PARAMETER      :: N9PFyl    = 266
   INTEGER(IntKi), PARAMETER      :: N9PFzl    = 267
   INTEGER(IntKi), PARAMETER      :: N1PMxl    = 268
   INTEGER(IntKi), PARAMETER      :: N1PMyl    = 269
   INTEGER(IntKi), PARAMETER      :: N1PMzl    = 270
   INTEGER(IntKi), PARAMETER      :: N2PMxl    = 271
   INTEGER(IntKi), PARAMETER      :: N2PMyl    = 272
   INTEGER(IntKi), PARAMETER      :: N2PMzl    = 273
   INTEGER(IntKi), PARAMETER      :: N3PMxl    = 274
   INTEGER(IntKi), PARAMETER      :: N3PMyl    = 275
   INTEGER(IntKi), PARAMETER      :: N3PMzl    = 276
   INTEGER(IntKi), PARAMETER      :: N4PMxl    = 277
   INTEGER(IntKi), PARAMETER      :: N4PMyl    = 278
   INTEGER(IntKi), PARAMETER      :: N4PMzl    = 279
   INTEGER(IntKi), PARAMETER      :: N5PMxl    = 280
   INTEGER(IntKi), PARAMETER      :: N5PMyl    = 281
   INTEGER(IntKi), PARAMETER      :: N5PMzl    = 282
   INTEGER(IntKi), PARAMETER      :: N6PMxl    = 283
   INTEGER(IntKi), PARAMETER      :: N6PMyl    = 284
   INTEGER(IntKi), PARAMETER      :: N6PMzl    = 285
   INTEGER(IntKi), PARAMETER      :: N7PMxl    = 286
   INTEGER(IntKi), PARAMETER      :: N7PMyl    = 287
   INTEGER(IntKi), PARAMETER      :: N7PMzl    = 288
   INTEGER(IntKi), PARAMETER      :: N8PMxl    = 289
   INTEGER(IntKi), PARAMETER      :: N8PMyl    = 290
   INTEGER(IntKi), PARAMETER      :: N8PMzl    = 291
   INTEGER(IntKi), PARAMETER      :: N9PMxl    = 292
   INTEGER(IntKi), PARAMETER      :: N9PMyl    = 293
   INTEGER(IntKi), PARAMETER      :: N9PMzl    = 294
   INTEGER(IntKi), PARAMETER      :: N1DFxl    = 295
   INTEGER(IntKi), PARAMETER      :: N1DFyl    = 296
   INTEGER(IntKi), PARAMETER      :: N1DFzl    = 297
   INTEGER(IntKi), PARAMETER      :: N2DFxl    = 298
   INTEGER(IntKi), PARAMETER      :: N2DFyl    = 299
   INTEGER(IntKi), PARAMETER      :: N2DFzl    = 300
   INTEGER(IntKi), PARAMETER      :: N3DFxl    = 301
   INTEGER(IntKi), PARAMETER      :: N3DFyl    = 302
   INTEGER(IntKi), PARAMETER      :: N3DFzl    = 303
   INTEGER(IntKi), PARAMETER      :: N4DFxl    = 304
   INTEGER(IntKi), PARAMETER      :: N4DFyl    = 305
   INTEGER(IntKi), PARAMETER      :: N4DFzl    = 306
   INTEGER(IntKi), PARAMETER      :: N5DFxl    = 307
   INTEGER(IntKi), PARAMETER      :: N5DFyl    = 308
   INTEGER(IntKi), PARAMETER      :: N5DFzl    = 309
   INTEGER(IntKi), PARAMETER      :: N6DFxl    = 310
   INTEGER(IntKi), PARAMETER      :: N6DFyl    = 311
   INTEGER(IntKi), PARAMETER      :: N6DFzl    = 312
   INTEGER(IntKi), PARAMETER      :: N7DFxl    = 313
   INTEGER(IntKi), PARAMETER      :: N7DFyl    = 314
   INTEGER(IntKi), PARAMETER      :: N7DFzl    = 315
   INTEGER(IntKi), PARAMETER      :: N8DFxl    = 316
   INTEGER(IntKi), PARAMETER      :: N8DFyl    = 317
   INTEGER(IntKi), PARAMETER      :: N8DFzl    = 318
   INTEGER(IntKi), PARAMETER      :: N9DFxl    = 319
   INTEGER(IntKi), PARAMETER      :: N9DFyl    = 320
   INTEGER(IntKi), PARAMETER      :: N9DFzl    = 321
   INTEGER(IntKi), PARAMETER      :: N1DMxl    = 322
   INTEGER(IntKi), PARAMETER      :: N1DMyl    = 323
   INTEGER(IntKi), PARAMETER      :: N1DMzl    = 324
   INTEGER(IntKi), PARAMETER      :: N2DMxl    = 325
   INTEGER(IntKi), PARAMETER      :: N2DMyl    = 326
   INTEGER(IntKi), PARAMETER      :: N2DMzl    = 327
   INTEGER(IntKi), PARAMETER      :: N3DMxl    = 328
   INTEGER(IntKi), PARAMETER      :: N3DMyl    = 329
   INTEGER(IntKi), PARAMETER      :: N3DMzl    = 330
   INTEGER(IntKi), PARAMETER      :: N4DMxl    = 331
   INTEGER(IntKi), PARAMETER      :: N4DMyl    = 332
   INTEGER(IntKi), PARAMETER      :: N4DMzl    = 333
   INTEGER(IntKi), PARAMETER      :: N5DMxl    = 334
   INTEGER(IntKi), PARAMETER      :: N5DMyl    = 335
   INTEGER(IntKi), PARAMETER      :: N5DMzl    = 336
   INTEGER(IntKi), PARAMETER      :: N6DMxl    = 337
   INTEGER(IntKi), PARAMETER      :: N6DMyl    = 338
   INTEGER(IntKi), PARAMETER      :: N6DMzl    = 339
   INTEGER(IntKi), PARAMETER      :: N7DMxl    = 340
   INTEGER(IntKi), PARAMETER      :: N7DMyl    = 341
   INTEGER(IntKi), PARAMETER      :: N7DMzl    = 342
   INTEGER(IntKi), PARAMETER      :: N8DMxl    = 343
   INTEGER(IntKi), PARAMETER      :: N8DMyl    = 344
   INTEGER(IntKi), PARAMETER      :: N8DMzl    = 345
   INTEGER(IntKi), PARAMETER      :: N9DMxl    = 346
   INTEGER(IntKi), PARAMETER      :: N9DMyl    = 347
   INTEGER(IntKi), PARAMETER      :: N9DMzl    = 348


     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER      :: MaxOutPts = 348

!End of code generated by Matlab script
! ===================================================================================================
   
   INTEGER,  PARAMETER          :: NFl(9, 3) = RESHAPE( (/ &      ! Sectional force resultants expressed in l
                                     N1Fxl,N2Fxl,N3Fxl,N4Fxl,N5Fxl,N6Fxl,N7Fxl,N8Fxl,N9Fxl, &
                                     N1Fyl,N2Fyl,N3Fyl,N4Fyl,N5Fyl,N6Fyl,N7Fyl,N8Fyl,N9Fyl, &
                                     N1Fzl,N2Fzl,N3Fzl,N4Fzl,N5Fzl,N6Fzl,N7Fzl,N8Fzl,N9Fzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NMl(9, 3) = RESHAPE( (/ &      ! Sectional moment resultants expressed in l
                                     N1Mxl,N2Mxl,N3Mxl,N4Mxl,N5Mxl,N6Mxl,N7Mxl,N8Mxl,N9Mxl, &
                                     N1Myl,N2Myl,N3Myl,N4Myl,N5Myl,N6Myl,N7Myl,N8Myl,N9Myl, &
                                     N1Mzl,N2Mzl,N3Mzl,N4Mzl,N5Mzl,N6Mzl,N7Mzl,N8Mzl,N9Mzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NTDr(9, 3) = RESHAPE( (/ &      ! Sectional translational deflections expressed in r
                                     N1TDxr,N2TDxr,N3TDxr,N4TDxr,N5TDxr,N6TDxr,N7TDxr,N8TDxr,N9TDxr, &
                                     N1TDyr,N2TDyr,N3TDyr,N4TDyr,N5TDyr,N6TDyr,N7TDyr,N8TDyr,N9TDyr, &
                                     N1TDzr,N2TDzr,N3TDzr,N4TDzr,N5TDzr,N6TDzr,N7TDzr,N8TDzr,N9TDzr  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NRDr(9, 3) = RESHAPE( (/ &      ! Sectional angular/rotational deflections expressed in r
                                     N1RDxr,N2RDxr,N3RDxr,N4RDxr,N5RDxr,N6RDxr,N7RDxr,N8RDxr,N9RDxr, &
                                     N1RDyr,N2RDyr,N3RDyr,N4RDyr,N5RDyr,N6RDyr,N7RDyr,N8RDyr,N9RDyr, &
                                     N1RDzr,N2RDzr,N3RDzr,N4RDzr,N5RDzr,N6RDzr,N7RDzr,N8RDzr,N9RDzr  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NTVg(9, 3) = RESHAPE( (/ &      ! Sectional translational velocities expressed in g
                                     N1TVXg,N2TVXg,N3TVXg,N4TVXg,N5TVXg,N6TVXg,N7TVXg,N8TVXg,N9TVXg, &
                                     N1TVYg,N2TVYg,N3TVYg,N4TVYg,N5TVYg,N6TVYg,N7TVYg,N8TVYg,N9TVYg, &
                                     N1TVZg,N2TVZg,N3TVZg,N4TVZg,N5TVZg,N6TVZg,N7TVZg,N8TVZg,N9TVZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NRVg(9, 3) = RESHAPE( (/ &      ! Sectional angular/rotational velocities expressed in g
                                     N1RVXg,N2RVXg,N3RVXg,N4RVXg,N5RVXg,N6RVXg,N7RVXg,N8RVXg,N9RVXg, &
                                     N1RVYg,N2RVYg,N3RVYg,N4RVYg,N5RVYg,N6RVYg,N7RVYg,N8RVYg,N9RVYg, &
                                     N1RVZg,N2RVZg,N3RVZg,N4RVZg,N5RVZg,N6RVZg,N7RVZg,N8RVZg,N9RVZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NTAg(9, 3) = RESHAPE( (/ &      ! Sectional translational accelerations expressed in g
                                     N1TAXg,N2TAXg,N3TAXg,N4TAXg,N5TAXg,N6TAXg,N7TAXg,N8TAXg,N9TAXg, &
                                     N1TAYg,N2TAYg,N3TAYg,N4TAYg,N5TAYg,N6TAYg,N7TAYg,N8TAYg,N9TAYg, &
                                     N1TAZg,N2TAZg,N3TAZg,N4TAZg,N5TAZg,N6TAZg,N7TAZg,N8TAZg,N9TAZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NRAg(9, 3) = RESHAPE( (/ &      ! Sectional angular/rotational accelerations expressed in g
                                     N1RAXg,N2RAXg,N3RAXg,N4RAXg,N5RAXg,N6RAXg,N7RAXg,N8RAXg,N9RAXg, &
                                     N1RAYg,N2RAYg,N3RAYg,N4RAYg,N5RAYg,N6RAYg,N7RAYg,N8RAYg,N9RAYg, &
                                     N1RAZg,N2RAZg,N3RAZg,N4RAZg,N5RAZg,N6RAZg,N7RAZg,N8RAZg,N9RAZg  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NPFl(9, 3) = RESHAPE( (/ &      ! Applied point forces expressed in l
                                     N1PFxl,N2PFxl,N3PFxl,N4PFxl,N5PFxl,N6PFxl,N7PFxl,N8PFxl,N9PFxl, &
                                     N1PFyl,N2PFyl,N3PFyl,N4PFyl,N5PFyl,N6PFyl,N7PFyl,N8PFyl,N9PFyl, &
                                     N1PFzl,N2PFzl,N3PFzl,N4PFzl,N5PFzl,N6PFzl,N7PFzl,N8PFzl,N9PFzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NPMl(9, 3) = RESHAPE( (/ &      ! Applied point moments expressed in l
                                     N1PMxl,N2PMxl,N3PMxl,N4PMxl,N5PMxl,N6PMxl,N7PMxl,N8PMxl,N9PMxl, &
                                     N1PMyl,N2PMyl,N3PMyl,N4PMyl,N5PMyl,N6PMyl,N7PMyl,N8PMyl,N9PMyl, &
                                     N1PMzl,N2PMzl,N3PMzl,N4PMzl,N5PMzl,N6PMzl,N7PMzl,N8PMzl,N9PMzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NDFl(9, 3) = RESHAPE( (/ &      ! Applied distributed forces expressed in l
                                     N1DFxl,N2DFxl,N3DFxl,N4DFxl,N5DFxl,N6DFxl,N7DFxl,N8DFxl,N9DFxl, &
                                     N1DFyl,N2DFyl,N3DFyl,N4DFyl,N5DFyl,N6DFyl,N7DFyl,N8DFyl,N9DFyl, &
                                     N1DFzl,N2DFzl,N3DFzl,N4DFzl,N5DFzl,N6DFzl,N7DFzl,N8DFzl,N9DFzl  &
                                   /), (/9, 3/) )
   INTEGER,  PARAMETER          :: NDMl(9, 3) = RESHAPE( (/ &      ! Applied distributed moments expressed in l
                                     N1DMxl,N2DMxl,N3DMxl,N4DMxl,N5DMxl,N6DMxl,N7DMxl,N8DMxl,N9DMxl, &
                                     N1DMyl,N2DMyl,N3DMyl,N4DMyl,N5DMyl,N6DMyl,N7DMyl,N8DMyl,N9DMyl, &
                                     N1DMzl,N2DMzl,N3DMzl,N4DMzl,N5DMzl,N6DMzl,N7DMzl,N8DMzl,N9DMzl  &
                                   /), (/9, 3/) )
   
   
CONTAINS
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE BD_ReadInput(InputFileName,InputFileData,OutFileRoot, Default_DT,ErrStat,ErrMsg)

   ! Passed Variables:
   CHARACTER(*),                 INTENT(IN   )  :: InputFileName    ! Name of the input file
   CHARACTER(*),                 INTENT(IN   )  :: OutFileRoot     ! Name of the input file
   REAL(DbKi),                   INTENT(IN   )    :: Default_DT      ! The default DT (from glue code)
   TYPE(BD_InputFile),           INTENT(  OUT)  :: InputFileData    ! Data stored in the module's input file
   INTEGER(IntKi),               INTENT(  OUT)  :: ErrStat          ! The error status code
   CHARACTER(*),                 INTENT(  OUT)  :: ErrMsg           ! The error message, if an error occurred


   ! Local variables:
   INTEGER(IntKi)                               :: UnEcho
   INTEGER(IntKi)                               :: ErrStat2
   CHARACTER(ErrMsgLen)                         :: ErrMsg2
   character(*), parameter                      :: RoutineName = 'BD_ReadInput'


   ErrStat = ErrID_None
   ErrMsg = ''

   InputFileData%DTBeam = Default_DT
   CALL BD_ReadPrimaryFile(InputFileName,InputFileData,OutFileRoot,UnEcho,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   CALL BD_ReadBladeFile(InputFileData%BldFile,InputFileData%InpBl,UnEcho,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   IF(ErrStat >= AbortErrLev) RETURN

END SUBROUTINE BD_ReadInput
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE BD_ReadPrimaryFile(InputFile,InputFileData,&
                              OutFileRoot,UnEc,ErrStat,ErrMsg)
!----------------------------------------------------------------------------------------------------------------------------------
! This routine reads in the primary BeamDyn input file and places the values it reads
! in the InputFileData structure.
!   It opens an echo file if requested and returns the (still-open) echo file to the
!     calling routine.
!------------------------------------------------------------------------------------

   ! Passed variables
   INTEGER(IntKi),               INTENT(  OUT) :: UnEc
   INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
   CHARACTER(*),                 INTENT(IN   ) :: InputFile
   CHARACTER(*),                 INTENT(IN   ) :: OutFileRoot
   CHARACTER(*),                 INTENT(  OUT) :: ErrMsg

   TYPE(BD_InputFile),           INTENT(INOUT) :: InputFileData

   ! Local variables:
   INTEGER(IntKi)               :: UnIn                         ! Unit number for reading file
   INTEGER(IntKi)               :: ErrStat2                     ! Temporary Error status
   LOGICAL                      :: Echo                         ! Determines if an echo file should be written
   INTEGER(IntKi)               :: IOS                          ! Temporary Error status
   CHARACTER(ErrMsgLen)         :: ErrMsg2                      ! Temporary Error message
   character(*), parameter      :: RoutineName = 'BD_ReadPrimaryFile'
   
   CHARACTER(1024)              :: PriPath                      ! Path name of the primary file
   CHARACTER(1024)              :: FTitle                       ! "File Title": the 2nd line of the input file, which contains a description of its contents
   CHARACTER(200)               :: Line                         ! Temporary storage of a line from the input

   INTEGER(IntKi)               :: i
   INTEGER(IntKi)               :: j
   INTEGER(IntKi)               :: temp_int
   REAL(ReKi)                   :: tmpReAry(4)

   ! Initialize some variables:
   ErrStat = ErrID_None
   ErrMsg  = ""
   Echo = .FALSE.
   UnEc = -1
   CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.

   CALL AllocAry( InputFileData%OutList, MaxOutPts, "Outlist", ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
   
   CALL GetNewUnit(UnIn,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL OpenFInpFile(UnIn,InputFile,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) RETURN
      
   !-------------------------- HEADER ---------------------------------------------
   CALL ReadCom(UnIn,InputFile,'File Header: Module Version (line 1)',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadStr(UnIn,InputFile,FTitle,'FTitle','File Header: File Description (line 2)',ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if

   !---------------------- SIMULATION CONTROL --------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Simulation Control',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,Echo,'Echo','Echo switch',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
!   IF(Echo) THEN
!       CALL OpenEcho(UnEc,OutFileRoot//'.ech',ErrStat2,ErrMsg2)
!          CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
!          if (ErrStat >= AbortErrLev) then
!             call cleanup()
!             return
!          end if
!   ENDIF
!   IF ( UnEc > 0 )  WRITE(UnEc,*)  'test'
   CALL ReadVar(UnIn,InputFile,InputFileData%analysis_type,"analysis_type", "Analysis type",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,InputFileData%rhoinf,"rhoinf", "Coefficient for GA2",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "DTBeam", "Time interval for BeamDyn  calculations {or default} (s)", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) /= 1 ) THEN ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%DTBeam
            CALL CheckIOS ( IOS, InputFile, 'DTBeam', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF

   CALL ReadVar( UnIn, InputFile, Line, "NRMax", "Max number of interations in Newton-Raphson algorithm", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) .EQ. 1) THEN
          InputFileData%NRMax = 10
      ELSE ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%NRMax
            CALL CheckIOS ( IOS, InputFile, 'NRMax', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF
      
   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "stop_tol", "Tolerance for stopping criterion", ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) .EQ. 1) THEN
          InputFileData%stop_tol = 1.0D-05
      ELSE ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTBeam
         READ( Line, *, IOSTAT=IOS) InputFileData%stop_tol
            CALL CheckIOS ( IOS, InputFile, 'stop_tol', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF

      if (ErrStat >= AbortErrLev) then
         call cleanup()
         return
      end if
      
   !---------------------- GEOMETRY PARAMETER --------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Geometry Parameter',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,InputFileData%member_total,"member_total", "Total number of member",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadVar(UnIn,InputFile,InputFileData%kp_total,"kp_total", "Total number of key point",ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      CALL AllocAry(InputFileData%kp_member,InputFileData%member_total,'Number of key point in each member',ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      CALL AllocAry(InputFileData%kp_coordinate,InputFileData%kp_total,4,'Key point coordinates input array',ErrStat2,ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         if (ErrStat >= AbortErrLev) then
            call cleanup()
            return
         end if
         
   InputFileData%kp_member(:) = 0
   InputFileData%kp_coordinate(:,:) = 0.0D0
   temp_int = 0
   DO i=1,InputFileData%member_total
      ! bjj: we cannot read j, InputFileData%kp_member(j) because j could be outside the valid range:
      READ(UnIn,*,IOSTAT=IOS) j,temp_int 
         CALL CheckIOS ( IOS, InputFile, 'Member number; Number of key points in this member', NumType, ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         if (ErrStat >= AbortErrLev) then
            call cleanup()
            return
         end if
         
         if (j>0 .and. j<= InputFileData%member_total) then
            InputFileData%kp_member(j) = temp_int
         end if
         
         !bjj: what happens if the user enters a member number multiple times? or if not each member is accounted for?
         !    I'm going to force them to be entered 1-InputFileData%kp_member to avoid this issue for now.
         if (j /= i) then
            call SetErrStat(ErrID_Warn, "Member numbers must be entered in monotonic increasing order, starting with 1.",ErrStat,ErrMsg,RoutineName)
         end if
         
   ENDDO
   
   
   CALL ReadCom(UnIn,InputFile,'key point x,y,z locations and initial twist angles',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   CALL ReadCom(UnIn,InputFile,'key point and initial twist units',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   DO i=1,InputFileData%kp_total
       CALL ReadAry( UnIn, InputFile, TmpReAry, 4, 'kp_coordinate', 'Key point coordinates and initial twist', ErrStat2, ErrMsg2, UnEc )       
          CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
       InputFileData%kp_coordinate(i,2) =  TmpReAry(1)
       InputFileData%kp_coordinate(i,3) =  TmpReAry(2)
       InputFileData%kp_coordinate(i,1) =  TmpReAry(3)
       InputFileData%kp_coordinate(i,4) = -TmpReAry(4)
   ENDDO
   
   !---------------------- MESH PARAMETER -----------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Mesh Parameter',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadVar(UnIn,InputFile,InputFileData%order_elem,"order_elem","Order of basis function",&
                ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   !---------------------- BEAM SECTIONAL PARAMETER ----------------------------------------
   CALL ReadCom(UnIn,InputFile,'Section Header: Blade Parameter',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadVar ( UnIn, InputFile, InputFileData%BldFile, 'MatFile', 'Name of the file containing properties for beam', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( PathIsRelative( InputFileData%BldFile ) ) InputFileData%BldFile = TRIM(PriPath)//TRIM(InputFileData%BldFile)

      
   !----------- OUTPUTS  -----------------------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Outputs', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      ! NNodeOuts - Number of node outputs [0 - 9] (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%NNodeOuts, "NNodeOuts", "Number of node outputs [0 - 9] (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      IF ( InputFileData%NNodeOuts > SIZE(InputFileData%OutNd) ) THEN
         CALL SetErrStat( ErrID_Warn, ' Warning: number of output nodes exceeds '//&
                           TRIM(Num2LStr(SIZE(InputFileData%OutNd))) //'.', ErrStat, ErrMsg, RoutineName )
         InputFileData%NNodeOuts = SIZE(InputFileData%OutNd)
      END IF
      
      ! OutNd - Nodes whose values will be output (-):
   CALL ReadAry( UnIn, InputFile, InputFileData%OutNd, InputFileData%NNodeOuts, "OutNd", "Nodes whose values will be output (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
            

      ! Return on error at end of section
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   END IF
                  
   !----------- OUTLIST  -----------------------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: OutList', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      ! OutList - List of user-requested output channels (-):
   CALL ReadOutputList ( UnIn, InputFile, InputFileData%OutList, InputFileData%NumOuts, 'OutList', "List of user-requested output channels", ErrStat2, ErrMsg2, UnEc  )     ! Routine in NWTC Subroutine Library
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
   !---------------------- END OF FILE -----------------------------------------      
      
      
   call cleanup()
   return
      
contains
   subroutine cleanup() 
      close(UnIn)
      return
   end subroutine cleanup         
END SUBROUTINE BD_ReadPrimaryFile
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE BD_ReadBladeFile(BldFile,BladeInputFileData,UnEc,ErrStat,ErrMsg)

   ! Passed variables:
   TYPE(BladeInputData), INTENT(  OUT):: BladeInputFileData
   CHARACTER(*),         INTENT(IN   ):: BldFile
   INTEGER(IntKi),       INTENT(IN   ):: UnEc
   INTEGER(IntKi),       INTENT(  OUT):: ErrStat                             ! Error status
   CHARACTER(*),         INTENT(  OUT):: ErrMsg                              ! Error message

   ! Local variables:
   INTEGER(IntKi)             :: UnIn                                            ! Unit number for reading file
   INTEGER(IntKi)             :: ErrStat2                                        ! Temporary Error status
   CHARACTER(ErrMsgLen)       :: ErrMsg2                                         ! Temporary Err msg
   character(*), parameter    :: RoutineName = 'BD_ReadBladeFile'
   INTEGER(IntKi)             :: i
   INTEGER(IntKi)             :: j

   ErrStat = ErrID_None
   ErrMsg  = ""

   CALL GetNewUnit(UnIn,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL OpenFInpFile (UnIn,BldFile,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         if (ErrStat >= AbortErrLev) then
            return
         end if

   !  -------------- HEADER -------------------------------------------------------
   ! Skip the header.
   CALL ReadCom(UnIn,BldFile,'unused beam file header line 1',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadCom(UnIn,BldFile,'unused beam file header line 2',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   !  -------------- BLADE PARAMETER-----------------------------------------------
   CALL ReadCom(UnIn,BldFile,'beam parameters',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL ReadVar(UnIn,BldFile,BladeInputFileData%station_total,'station_total','Number of blade input stations',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL AllocAry(BladeInputFileData%stiff0,6,6,BladeInputFileData%station_total,'Cross-sectional 6 by 6 stiffness matrix',ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   BladeInputFileData%stiff0(:,:,:) = 0.0D0
   CALL AllocAry(BladeInputFileData%mass0,6,6,BladeInputFileData%station_total,'Cross-sectional 6 by 6 mass matrix',ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   BladeInputFileData%mass0(:,:,:) = 0.0D0
   CALL AllocAry(BladeInputFileData%station_eta,BladeInputFileData%station_total,'Station eta array',ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   BladeInputFileData%station_eta(:) = 0.0D0
   CALL ReadVar(UnIn,BldFile,BladeInputFileData%damp_flag,'damp_flag','Damping flag',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   !  -------------- DAMPING PARAMETER-----------------------------------------------
   CALL ReadCom(UnIn,BldFile,'damping parameters',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadCom(UnIn,BldFile,'mu1 to mu6',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadCom(UnIn,BldFile,'units',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL AllocAry(BladeInputFileData%beta,6,'Number of damping coefficient',ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL ReadAry(UnIn,BldFile,BladeInputFileData%beta(:),6,'damping coefficient','damping coefficient',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
!  -------------- DISTRIBUTED PROPERTIES--------------------------------------------
   CALL ReadCom(UnIn,BldFile,'Distributed properties',ErrStat2,ErrMsg2,UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   DO i=1,BladeInputFileData%station_total
       READ(UnIn,*) BladeInputFileData%station_eta(i)
       DO j=1,6
           CALL ReadAry(UnIn,BldFile,BladeInputFileData%stiff0(j,:,i),6,'siffness_matrix',&
                   'Blade C/S stiffness matrix',ErrStat2,ErrMsg2,UnEc)
              CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
       ENDDO
!       temp66(:,:) = 0.0D0
!       temp66(:,:) = BladeInputFileData%stiff0(:,:,i)
!       DO j=1,6
!           BladeInputFileData%stiff0(j,1,i) = temp66(j,3)
!           BladeInputFileData%stiff0(j,2,i) = temp66(j,1)
!           BladeInputFileData%stiff0(j,3,i) = temp66(j,2)
!           BladeInputFileData%stiff0(j,4,i) = temp66(j,6)
!           BladeInputFileData%stiff0(j,5,i) = temp66(j,4)
!           BladeInputFileData%stiff0(j,6,i) = temp66(j,5)
!       ENDDO
!       temp66(:,:) = 0.0D0
!       temp66(:,:) = BladeInputFileData%stiff0(:,:,i)
!       BladeInputFileData%stiff0(1,:,i) = temp66(3,:)
!       BladeInputFileData%stiff0(2,:,i) = temp66(1,:)
!       BladeInputFileData%stiff0(3,:,i) = temp66(2,:)
!       BladeInputFileData%stiff0(4,:,i) = temp66(6,:)
!       BladeInputFileData%stiff0(5,:,i) = temp66(4,:)
!       BladeInputFileData%stiff0(6,:,i) = temp66(5,:)
       DO j=1,6
           CALL ReadAry(UnIn,BldFile,BladeInputFileData%mass0(j,:,i),6,'mass_matrix',&
                   'Blade C/S mass matrix',ErrStat2,ErrMsg2,UnEc)
              CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
       ENDDO
!       temp66(:,:) = 0.0D0
!       temp66(:,:) = BladeInputFileData%mass0(:,:,i)
!       DO j=1,6
!           BladeInputFileData%mass0(j,1,i) = temp66(j,3)
!           BladeInputFileData%mass0(j,2,i) = temp66(j,1)
!           BladeInputFileData%mass0(j,3,i) = temp66(j,2)
!           BladeInputFileData%mass0(j,4,i) = temp66(j,6)
!           BladeInputFileData%mass0(j,5,i) = temp66(j,4)
!           BladeInputFileData%mass0(j,6,i) = temp66(j,5)
!       ENDDO
!       temp66(:,:) = 0.0D0
!       temp66(:,:) = BladeInputFileData%mass0(:,:,i)
!       BladeInputFileData%mass0(1,:,i) = temp66(3,:)
!       BladeInputFileData%mass0(2,:,i) = temp66(1,:)
!       BladeInputFileData%mass0(3,:,i) = temp66(2,:)
!       BladeInputFileData%mass0(4,:,i) = temp66(6,:)
!       BladeInputFileData%mass0(5,:,i) = temp66(4,:)
!       BladeInputFileData%mass0(6,:,i) = temp66(5,:)
   ENDDO

   call cleanup()
   return
      
contains
   subroutine cleanup() 
      close(UnIn)
      return
   end subroutine cleanup         
END SUBROUTINE BD_ReadBladeFile
!----------------------------------------------------------------------------------------------------------------------------------
!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! This code was generated by Write_ChckOutLst.m at 25-Jul-2015 15:42:20.
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SetOutParam(OutList, p, ErrStat, ErrMsg )
! This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
! warning if any of the channels are not available outputs from the module.
!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!  the sign is set to 0 if the channel is invalid.
! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN)     :: OutList(:)                        ! The list out user-requested outputs
   TYPE(BD_ParameterType),    INTENT(INOUT)  :: p                                 ! The module parameters
   INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           ! The error status code
   CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            ! The error message, if an error occurred

      ! Local variables

   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
   LOGICAL                      :: InvalidOutput(0:MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(348) =  (/ &                  ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "N1DFXL   ","N1DFYL   ","N1DFZL   ","N1DMXL   ","N1DMYL   ","N1DMZL   ","N1FXL    ", &
                               "N1FYL    ","N1FZL    ","N1MXL    ","N1MYL    ","N1MZL    ","N1PFXL   ","N1PFYL   ", &
                               "N1PFZL   ","N1PMXL   ","N1PMYL   ","N1PMZL   ","N1RAXG   ","N1RAYG   ","N1RAZG   ", &
                               "N1RDXR   ","N1RDYR   ","N1RDZR   ","N1RVXG   ","N1RVYG   ","N1RVZG   ","N1TAXG   ", &
                               "N1TAYG   ","N1TAZG   ","N1TDXR   ","N1TDYR   ","N1TDZR   ","N1TVXG   ","N1TVYG   ", &
                               "N1TVZG   ","N2DFXL   ","N2DFYL   ","N2DFZL   ","N2DMXL   ","N2DMYL   ","N2DMZL   ", &
                               "N2FXL    ","N2FYL    ","N2FZL    ","N2MXL    ","N2MYL    ","N2MZL    ","N2PFXL   ", &
                               "N2PFYL   ","N2PFZL   ","N2PMXL   ","N2PMYL   ","N2PMZL   ","N2RAXG   ","N2RAYG   ", &
                               "N2RAZG   ","N2RDXR   ","N2RDYR   ","N2RDZR   ","N2RVXG   ","N2RVYG   ","N2RVZG   ", &
                               "N2TAXG   ","N2TAYG   ","N2TAZG   ","N2TDXR   ","N2TDYR   ","N2TDZR   ","N2TVXG   ", &
                               "N2TVYG   ","N2TVZG   ","N3DFXL   ","N3DFYL   ","N3DFZL   ","N3DMXL   ","N3DMYL   ", &
                               "N3DMZL   ","N3FXL    ","N3FYL    ","N3FZL    ","N3MXL    ","N3MYL    ","N3MZL    ", &
                               "N3PFXL   ","N3PFYL   ","N3PFZL   ","N3PMXL   ","N3PMYL   ","N3PMZL   ","N3RAXG   ", &
                               "N3RAYG   ","N3RAZG   ","N3RDXR   ","N3RDYR   ","N3RDZR   ","N3RVXG   ","N3RVYG   ", &
                               "N3RVZG   ","N3TAXG   ","N3TAYG   ","N3TAZG   ","N3TDXR   ","N3TDYR   ","N3TDZR   ", &
                               "N3TVXG   ","N3TVYG   ","N3TVZG   ","N4DFXL   ","N4DFYL   ","N4DFZL   ","N4DMXL   ", &
                               "N4DMYL   ","N4DMZL   ","N4FXL    ","N4FYL    ","N4FZL    ","N4MXL    ","N4MYL    ", &
                               "N4MZL    ","N4PFXL   ","N4PFYL   ","N4PFZL   ","N4PMXL   ","N4PMYL   ","N4PMZL   ", &
                               "N4RAXG   ","N4RAYG   ","N4RAZG   ","N4RDXR   ","N4RDYR   ","N4RDZR   ","N4RVXG   ", &
                               "N4RVYG   ","N4RVZG   ","N4TAXG   ","N4TAYG   ","N4TAZG   ","N4TDXR   ","N4TDYR   ", &
                               "N4TDZR   ","N4TVXG   ","N4TVYG   ","N4TVZG   ","N5DFXL   ","N5DFYL   ","N5DFZL   ", &
                               "N5DMXL   ","N5DMYL   ","N5DMZL   ","N5FXL    ","N5FYL    ","N5FZL    ","N5MXL    ", &
                               "N5MYL    ","N5MZL    ","N5PFXL   ","N5PFYL   ","N5PFZL   ","N5PMXL   ","N5PMYL   ", &
                               "N5PMZL   ","N5RAXG   ","N5RAYG   ","N5RAZG   ","N5RDXR   ","N5RDYR   ","N5RDZR   ", &
                               "N5RVXG   ","N5RVYG   ","N5RVZG   ","N5TAXG   ","N5TAYG   ","N5TAZG   ","N5TDXR   ", &
                               "N5TDYR   ","N5TDZR   ","N5TVXG   ","N5TVYG   ","N5TVZG   ","N6DFXL   ","N6DFYL   ", &
                               "N6DFZL   ","N6DMXL   ","N6DMYL   ","N6DMZL   ","N6FXL    ","N6FYL    ","N6FZL    ", &
                               "N6MXL    ","N6MYL    ","N6MZL    ","N6PFXL   ","N6PFYL   ","N6PFZL   ","N6PMXL   ", &
                               "N6PMYL   ","N6PMZL   ","N6RAXG   ","N6RAYG   ","N6RAZG   ","N6RDXR   ","N6RDYR   ", &
                               "N6RDZR   ","N6RVXG   ","N6RVYG   ","N6RVZG   ","N6TAXG   ","N6TAYG   ","N6TAZG   ", &
                               "N6TDXR   ","N6TDYR   ","N6TDZR   ","N6TVXG   ","N6TVYG   ","N6TVZG   ","N7DFXL   ", &
                               "N7DFYL   ","N7DFZL   ","N7DMXL   ","N7DMYL   ","N7DMZL   ","N7FXL    ","N7FYL    ", &
                               "N7FZL    ","N7MXL    ","N7MYL    ","N7MZL    ","N7PFXL   ","N7PFYL   ","N7PFZL   ", &
                               "N7PMXL   ","N7PMYL   ","N7PMZL   ","N7RAXG   ","N7RAYG   ","N7RAZG   ","N7RDXR   ", &
                               "N7RDYR   ","N7RDZR   ","N7RVXG   ","N7RVYG   ","N7RVZG   ","N7TAXG   ","N7TAYG   ", &
                               "N7TAZG   ","N7TDXR   ","N7TDYR   ","N7TDZR   ","N7TVXG   ","N7TVYG   ","N7TVZG   ", &
                               "N8DFXL   ","N8DFYL   ","N8DFZL   ","N8DMXL   ","N8DMYL   ","N8DMZL   ","N8FXL    ", &
                               "N8FYL    ","N8FZL    ","N8MXL    ","N8MYL    ","N8MZL    ","N8PFXL   ","N8PFYL   ", &
                               "N8PFZL   ","N8PMXL   ","N8PMYL   ","N8PMZL   ","N8RAXG   ","N8RAYG   ","N8RAZG   ", &
                               "N8RDXR   ","N8RDYR   ","N8RDZR   ","N8RVXG   ","N8RVYG   ","N8RVZG   ","N8TAXG   ", &
                               "N8TAYG   ","N8TAZG   ","N8TDXR   ","N8TDYR   ","N8TDZR   ","N8TVXG   ","N8TVYG   ", &
                               "N8TVZG   ","N9DFXL   ","N9DFYL   ","N9DFZL   ","N9DMXL   ","N9DMYL   ","N9DMZL   ", &
                               "N9FXL    ","N9FYL    ","N9FZL    ","N9MXL    ","N9MYL    ","N9MZL    ","N9PFXL   ", &
                               "N9PFYL   ","N9PFZL   ","N9PMXL   ","N9PMYL   ","N9PMZL   ","N9RAXG   ","N9RAYG   ", &
                               "N9RAZG   ","N9RDXR   ","N9RDYR   ","N9RDZR   ","N9RVXG   ","N9RVYG   ","N9RVZG   ", &
                               "N9TAXG   ","N9TAYG   ","N9TAZG   ","N9TDXR   ","N9TDYR   ","N9TDZR   ","N9TVXG   ", &
                               "N9TVYG   ","N9TVZG   ","ROOTFXR  ","ROOTFYR  ","ROOTFZR  ","ROOTMXR  ","ROOTMYR  ", &
                               "ROOTMZR  ","TIPRAXG  ","TIPRAYG  ","TIPRAZG  ","TIPRDXR  ","TIPRDYR  ","TIPRDZR  ", &
                               "TIPRVXG  ","TIPRVYG  ","TIPRVZG  ","TIPTAXG  ","TIPTAYG  ","TIPTAZG  ","TIPTDXR  ", &
                               "TIPTDYR  ","TIPTDZR  ","TIPTVXG  ","TIPTVYG  ","TIPTVZG  "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(348) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                   N1DFxl ,    N1DFyl ,    N1DFzl ,    N1DMxl ,    N1DMyl ,    N1DMzl ,     N1Fxl , &
                                    N1Fyl ,     N1Fzl ,     N1Mxl ,     N1Myl ,     N1Mzl ,    N1PFxl ,    N1PFyl , &
                                   N1PFzl ,    N1PMxl ,    N1PMyl ,    N1PMzl ,    N1RAXg ,    N1RAYg ,    N1RAZg , &
                                   N1RDxr ,    N1RDyr ,    N1RDzr ,    N1RVXg ,    N1RVYg ,    N1RVZg ,    N1TAXg , &
                                   N1TAYg ,    N1TAZg ,    N1TDxr ,    N1TDyr ,    N1TDzr ,    N1TVXg ,    N1TVYg , &
                                   N1TVZg ,    N2DFxl ,    N2DFyl ,    N2DFzl ,    N2DMxl ,    N2DMyl ,    N2DMzl , &
                                    N2Fxl ,     N2Fyl ,     N2Fzl ,     N2Mxl ,     N2Myl ,     N2Mzl ,    N2PFxl , &
                                   N2PFyl ,    N2PFzl ,    N2PMxl ,    N2PMyl ,    N2PMzl ,    N2RAXg ,    N2RAYg , &
                                   N2RAZg ,    N2RDxr ,    N2RDyr ,    N2RDzr ,    N2RVXg ,    N2RVYg ,    N2RVZg , &
                                   N2TAXg ,    N2TAYg ,    N2TAZg ,    N2TDxr ,    N2TDyr ,    N2TDzr ,    N2TVXg , &
                                   N2TVYg ,    N2TVZg ,    N3DFxl ,    N3DFyl ,    N3DFzl ,    N3DMxl ,    N3DMyl , &
                                   N3DMzl ,     N3Fxl ,     N3Fyl ,     N3Fzl ,     N3Mxl ,     N3Myl ,     N3Mzl , &
                                   N3PFxl ,    N3PFyl ,    N3PFzl ,    N3PMxl ,    N3PMyl ,    N3PMzl ,    N3RAXg , &
                                   N3RAYg ,    N3RAZg ,    N3RDxr ,    N3RDyr ,    N3RDzr ,    N3RVXg ,    N3RVYg , &
                                   N3RVZg ,    N3TAXg ,    N3TAYg ,    N3TAZg ,    N3TDxr ,    N3TDyr ,    N3TDzr , &
                                   N3TVXg ,    N3TVYg ,    N3TVZg ,    N4DFxl ,    N4DFyl ,    N4DFzl ,    N4DMxl , &
                                   N4DMyl ,    N4DMzl ,     N4Fxl ,     N4Fyl ,     N4Fzl ,     N4Mxl ,     N4Myl , &
                                    N4Mzl ,    N4PFxl ,    N4PFyl ,    N4PFzl ,    N4PMxl ,    N4PMyl ,    N4PMzl , &
                                   N4RAXg ,    N4RAYg ,    N4RAZg ,    N4RDxr ,    N4RDyr ,    N4RDzr ,    N4RVXg , &
                                   N4RVYg ,    N4RVZg ,    N4TAXg ,    N4TAYg ,    N4TAZg ,    N4TDxr ,    N4TDyr , &
                                   N4TDzr ,    N4TVXg ,    N4TVYg ,    N4TVZg ,    N5DFxl ,    N5DFyl ,    N5DFzl , &
                                   N5DMxl ,    N5DMyl ,    N5DMzl ,     N5Fxl ,     N5Fyl ,     N5Fzl ,     N5Mxl , &
                                    N5Myl ,     N5Mzl ,    N5PFxl ,    N5PFyl ,    N5PFzl ,    N5PMxl ,    N5PMyl , &
                                   N5PMzl ,    N5RAXg ,    N5RAYg ,    N5RAZg ,    N5RDxr ,    N5RDyr ,    N5RDzr , &
                                   N5RVXg ,    N5RVYg ,    N5RVZg ,    N5TAXg ,    N5TAYg ,    N5TAZg ,    N5TDxr , &
                                   N5TDyr ,    N5TDzr ,    N5TVXg ,    N5TVYg ,    N5TVZg ,    N6DFxl ,    N6DFyl , &
                                   N6DFzl ,    N6DMxl ,    N6DMyl ,    N6DMzl ,     N6Fxl ,     N6Fyl ,     N6Fzl , &
                                    N6Mxl ,     N6Myl ,     N6Mzl ,    N6PFxl ,    N6PFyl ,    N6PFzl ,    N6PMxl , &
                                   N6PMyl ,    N6PMzl ,    N6RAXg ,    N6RAYg ,    N6RAZg ,    N6RDxr ,    N6RDyr , &
                                   N6RDzr ,    N6RVXg ,    N6RVYg ,    N6RVZg ,    N6TAXg ,    N6TAYg ,    N6TAZg , &
                                   N6TDxr ,    N6TDyr ,    N6TDzr ,    N6TVXg ,    N6TVYg ,    N6TVZg ,    N7DFxl , &
                                   N7DFyl ,    N7DFzl ,    N7DMxl ,    N7DMyl ,    N7DMzl ,     N7Fxl ,     N7Fyl , &
                                    N7Fzl ,     N7Mxl ,     N7Myl ,     N7Mzl ,    N7PFxl ,    N7PFyl ,    N7PFzl , &
                                   N7PMxl ,    N7PMyl ,    N7PMzl ,    N7RAXg ,    N7RAYg ,    N7RAZg ,    N7RDxr , &
                                   N7RDyr ,    N7RDzr ,    N7RVXg ,    N7RVYg ,    N7RVZg ,    N7TAXg ,    N7TAYg , &
                                   N7TAZg ,    N7TDxr ,    N7TDyr ,    N7TDzr ,    N7TVXg ,    N7TVYg ,    N7TVZg , &
                                   N8DFxl ,    N8DFyl ,    N8DFzl ,    N8DMxl ,    N8DMyl ,    N8DMzl ,     N8Fxl , &
                                    N8Fyl ,     N8Fzl ,     N8Mxl ,     N8Myl ,     N8Mzl ,    N8PFxl ,    N8PFyl , &
                                   N8PFzl ,    N8PMxl ,    N8PMyl ,    N8PMzl ,    N8RAXg ,    N8RAYg ,    N8RAZg , &
                                   N8RDxr ,    N8RDyr ,    N8RDzr ,    N8RVXg ,    N8RVYg ,    N8RVZg ,    N8TAXg , &
                                   N8TAYg ,    N8TAZg ,    N8TDxr ,    N8TDyr ,    N8TDzr ,    N8TVXg ,    N8TVYg , &
                                   N8TVZg ,    N9DFxl ,    N9DFyl ,    N9DFzl ,    N9DMxl ,    N9DMyl ,    N9DMzl , &
                                    N9Fxl ,     N9Fyl ,     N9Fzl ,     N9Mxl ,     N9Myl ,     N9Mzl ,    N9PFxl , &
                                   N9PFyl ,    N9PFzl ,    N9PMxl ,    N9PMyl ,    N9PMzl ,    N9RAXg ,    N9RAYg , &
                                   N9RAZg ,    N9RDxr ,    N9RDyr ,    N9RDzr ,    N9RVXg ,    N9RVYg ,    N9RVZg , &
                                   N9TAXg ,    N9TAYg ,    N9TAZg ,    N9TDxr ,    N9TDyr ,    N9TDzr ,    N9TVXg , &
                                   N9TVYg ,    N9TVZg ,   RootFxr ,   RootFyr ,   RootFzr ,   RootMxr ,   RootMyr , &
                                  RootMzr ,   TipRAXg ,   TipRAYg ,   TipRAZg ,   TipRDxr ,   TipRDyr ,   TipRDzr , &
                                  TipRVXg ,   TipRVYg ,   TipRVZg ,   TipTAXg ,   TipTAYg ,   TipTAZg ,   TipTDxr , &
                                  TipTDyr ,   TipTDzr ,   TipTVXg ,   TipTVYg ,   TipTVZg /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(348) =  (/ &                     ! This lists the units corresponding to the allowed parameters
                               "(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ", &
                               "(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ", &
                               "(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ", &
                               "(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ", &
                               "(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ", &
                               "(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ", &
                               "(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ", &
                               "(N-m/m)   ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ", &
                               "(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ", &
                               "(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ", &
                               "(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ", &
                               "(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ", &
                               "(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ", &
                               "(N-m)     ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ", &
                               "(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ", &
                               "(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ", &
                               "(m)       ","(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ", &
                               "(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ","(N)       ","(N-m)     ", &
                               "(N-m)     ","(N-m)     ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ", &
                               "(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ","(-)       ", &
                               "(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ", &
                               "(m)       ","(m)       ","(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ","(N/m)     ", &
                               "(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ","(N)       ", &
                               "(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ","(N)       ","(N-m)     ", &
                               "(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ", &
                               "(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ", &
                               "(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ","(m/s)     ","(N/m)     ", &
                               "(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ","(N)       ", &
                               "(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ","(N)       ", &
                               "(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ", &
                               "(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ", &
                               "(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ","(m/s)     ", &
                               "(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ","(N)       ", &
                               "(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ", &
                               "(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ","(m/s)     ", &
                               "(m/s)     ","(N/m)     ","(N/m)     ","(N/m)     ","(N-m/m)   ","(N-m/m)   ","(N-m/m)   ", &
                               "(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(N)       ", &
                               "(N)       ","(N)       ","(N-m)     ","(N-m)     ","(N-m)     ","(deg/s^2) ","(deg/s^2) ", &
                               "(deg/s^2) ","(-)       ","(-)       ","(-)       ","(deg/s)   ","(deg/s)   ","(deg/s)   ", &
                               "(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ","(m)       ","(m)       ","(m/s)     ", &
                               "(m/s)     ","(m/s)     ","(N)       ","(N)       ","(N)       ","(N-m)     ","(N-m)     ", &
                               "(N-m)     ","(deg/s^2) ","(deg/s^2) ","(deg/s^2) ","(-)       ","(-)       ","(-)       ", &
                               "(deg/s)   ","(deg/s)   ","(deg/s)   ","(m/s^2)   ","(m/s^2)   ","(m/s^2)   ","(m)       ", &
                               "(m)       ","(m)       ","(m/s)     ","(m/s)     ","(m/s)     "/)


      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


!   ..... Developer must add checking for invalid inputs here: .....
   DO I = p%NNodeOuts+1,9  ! Invalid nodes
      
      InvalidOutput( NFl( i,:) ) = .true.
      InvalidOutput( NMl( i,:) ) = .true.
      InvalidOutput( NTDr(i,:) ) = .true.
      InvalidOutput( NRDr(i,:) ) = .true.
      InvalidOutput( NTVg(i,:) ) = .true.
      InvalidOutput( NRVg(i,:) ) = .true.
      InvalidOutput( NTAg(i,:) ) = .true.
      InvalidOutput( NRAg(i,:) ) = .true.
      InvalidOutput( NPFl(i,:) ) = .true.
      InvalidOutput( NPMl(i,:) ) = .true.
      InvalidOutput( NDFl(i,:) ) = .true.
      InvalidOutput( NDMl(i,:) ) = .true.
         
   END DO   
!   ................. End of validity checking .................


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%OutParam(0:p%NumOuts) , STAT=ErrStat2 )
   IF ( ErrStat2 /= 0_IntKi )  THEN
      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the BeamDyn OutParam array.", ErrStat, ErrMsg, RoutineName )
      RETURN
   ENDIF

      ! Set index, name, and units for the time output channel:

   p%OutParam(0)%Indx  = Time
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.

   DO I = 1,p%NumOuts

      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)

      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a "-", "_", "m", or "M" character indicating "minus".


      CheckOutListAgain = .FALSE.

      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)
      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain   = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )


         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)

      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)

         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      END IF


      IF ( Indx > 0 ) THEN ! we found the channel name
         p%OutParam(I)%Indx     = ParamIndxAry(Indx)
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%OutParam(I)%Units = "INVALID"
            p%OutParam(I)%SignM = 0
         ELSE
            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
         END IF
      ELSE ! this channel isn't valid
         p%OutParam(I)%Indx  = Time                 ! pick any valid channel (I just picked "Time" here because it's universal)
         p%OutParam(I)%Units = "INVALID"
         p%OutParam(I)%SignM = 0                    ! multiply all results by zero

         CALL SetErrStat(ErrID_Fatal, TRIM(p%OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,RoutineName)
      END IF

   END DO

   RETURN
END SUBROUTINE SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************

!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE BD_ValidateInputData( InputFileData, ErrStat, ErrMsg )
! This routine validates the inputs from the BeamDyn input files.
!..................................................................................................................................
      
      ! Passed variables:

   TYPE(BD_InputFile),   INTENT(IN   ):: InputFileData                       ! All the data in the BeamDyn input file
   INTEGER(IntKi),       INTENT(  OUT):: ErrStat                             ! Error status
   CHARACTER(*),         INTENT(  OUT):: ErrMsg                              ! Error message

   
      ! local variables
   INTEGER(IntKi)                     :: i,j                                 ! loop counters
   INTEGER(IntKi)                     :: nNodes                              ! number of nodes that will be on the BldMotion mesh
      
   CHARACTER(*), PARAMETER            :: RoutineName = 'BD_ValidateInputData'
   
   ErrStat = ErrID_None
   ErrMsg  = ""
         
   IF(InputFileData%analysis_type .NE. 1 .AND. InputFileData%analysis_type .NE. 2) &
       CALL SetErrStat ( ErrID_Fatal, 'Analysis type must be 1 (static) or 2 (dynamic)', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%rhoinf .LT. 0.0 .OR. InputFileData%rhoinf .GT. 1.0) &
       CALL SetErrStat ( ErrID_Fatal, 'Numerical damping parameter \rho_{inf} must be in the range of [0.0,1.0]', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%member_total .LT. 1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'member_total must be greater than 0', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%kp_total .LT. 1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'kp_total must be greater than 0', ErrStat, ErrMsg, RoutineName )
   DO i=1,InputFileData%member_total
       IF(InputFileData%kp_member(i) .LT. 3) THEN
          CALL SetErrStat(ErrID_Fatal,'There must be at least three key points in '//TRIM(Num2LStr(i))//'th member.', ErrStat, ErrMsg,RoutineName)
          EXIT
       ENDIF
   ENDDO
   IF(SUM(InputFileData%kp_member) .NE. InputFileData%kp_total+InputFileData%member_total-1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'Geometric definition error: kp_total and key points in each member are inconsistent', ErrStat, ErrMsg,RoutineName)
       
   IF(InputFileData%order_elem .LT. 1 ) &
       CALL SetErrStat ( ErrID_Fatal, 'order_elem must be greater than 0', ErrStat, ErrMsg, RoutineName )
       
   IF(InputFileData%InpBl%station_total .LT. 2 ) &
       CALL SetErrStat ( ErrID_Fatal, 'Number of material stations along blade axis much be greater than 2', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%InpBl%station_eta(1) .NE. 0.0 ) &
       CALL SetErrStat ( ErrID_Fatal, 'The first station_eta must be equal to 0.0 (root)', ErrStat, ErrMsg, RoutineName )
   IF(InputFileData%InpBl%station_eta(InputFileData%InpBl%station_total) .NE. 1.0 ) &
       CALL SetErrStat ( ErrID_Fatal, 'The last station_eta must be equal to 1.0 (tip)', ErrStat, ErrMsg, RoutineName )
   
   IF (InputFileData%NRMax < 2) CALL SetErrStat ( ErrID_Fatal, 'Maximum number of iterations in Newton-Raphson (NRMax) must be greater than 1.', ErrStat, ErrMsg, RoutineName )
   IF (InputFileData%stop_tol < EPSILON(InputFileData%stop_tol) ) &
      CALL SetErrStat ( ErrID_Fatal, 'Tolerance for stopping (stop_tol) must be larger than machine precision ('//trim(num2lstr(EPSILON(InputFileData%stop_tol)))//').', ErrStat, ErrMsg, RoutineName )
       
   
      ! .............................
      ! check outputs:
      ! .............................
                     
   if ( ( InputFileData%NNodeOuts < 0_IntKi ) .OR. ( InputFileData%NNodeOuts > 9_IntKi ) )  then
      call SetErrStat( ErrID_Fatal, 'NNodeOuts must be between 0 and 9 (inclusive).', ErrStat, ErrMsg, RoutineName )
   else 

   ! Check to see if all OutNd(:) analysis points are existing analysis points:
   !bjj: FIX ME: I don't know if this is the correct maximum number:
      nNodes = (InputFileData%order_elem + 1)*InputFileData%member_total
      do j=1,InputFileData%NNodeOuts
         if ( InputFileData%OutNd(j) < 1_IntKi .OR. InputFileData%OutNd(j) > nNodes ) then
            call SetErrStat( ErrID_Fatal, ' All OutNd values must be between 1 and '//&
                    trim( Num2LStr( nNodes ) )//' (inclusive).', ErrStat, ErrMsg, RoutineName )
            exit ! stop checking this loop
         end if
      end do
      
   end if      
   
END SUBROUTINE BD_ValidateInputData
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Calc_WriteOutput( p, u, AllOuts, y, ErrStat, ErrMsg )
   
   ! this routine fills the AllOuts array, which is used to send data to the glue code to be written to an output file.

   TYPE(BD_ParameterType),    INTENT(IN   )  :: p                                 ! The module parameters
   TYPE(BD_InputType),        INTENT(IN   )  :: u                                 ! inputs
   REAL(ReKi),                INTENT(INOUT)  :: AllOuts(:)                        ! array of values to potentially write to file
   TYPE(BD_OutputType),       INTENT(IN   )  :: y                                 ! outputs
   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat                           ! The error status code
   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg                            ! The error message, if an error occurred

      ! local variables
   CHARACTER(*), PARAMETER                   :: RoutineName = 'Calc_WriteOutput'
   INTEGER(IntKi)                            :: ErrStat2
   CHARACTER(ErrMsgLen)                      :: ErrMsg2
   
   
   INTEGER(IntKi)                            :: j,beta
   REAL(ReKi)                                :: temp_glb(3)
   REAL(ReKi)                                :: temp_vec(3)
   REAL(ReKi)                                :: temp_glbp(3)
   REAL(ReKi)                                :: temp_roott(3)
   REAL(ReKi)                                :: temp_tip0(3)
   REAL(ReKi)                                :: temp_ini(3)
   REAL(ReKi)                                :: temp_cur(3)
   REAL(ReKi)                                :: temp_cc(3)
   REAL(ReKi)                                :: temp_R(3,3)
   
   
      ! start routine:
   ErrStat = ErrID_None
   ErrMsg  = ""
   
   CALL BD_CrvExtractCrv(p%GlbRot,temp_glb,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   temp_vec(:) = temp_glb(:)
   temp_glb(1) = temp_vec(2)
   temp_glb(2) = temp_vec(3)
   temp_glb(3) = temp_vec(1)
   !bjj: I don't these are the correct outputs, but you get the idea
   temp_vec(:) = 0.0D0
   temp_vec(:) = y%ReactionForce%Force(:,1)
   temp_vec(:) = MATMUL(u%RootMotion%Orientation(:,:,1),temp_vec)
!   AllOuts( RootFxr ) = y%ReactionForce%Force(1,1)
!   AllOuts( RootFyr ) = y%ReactionForce%Force(2,1)
!   AllOuts( RootFzr ) = y%ReactionForce%Force(3,1)
   AllOuts( RootFxr ) = temp_vec(1)
   AllOuts( RootFyr ) = temp_vec(2)
   AllOuts( RootFzr ) = temp_vec(3) 

   temp_vec(:) = 0.0D0
   temp_vec(:) = y%ReactionForce%Moment(:,1)
   temp_vec(:) = MATMUL(u%RootMotion%Orientation(:,:,1),temp_vec)
!   AllOuts( RootMxr ) = y%ReactionForce%Moment(1,1)
!   AllOuts( RootMyr ) = y%ReactionForce%Moment(2,1)
!   AllOuts( RootMzr ) = y%ReactionForce%Moment(3,1)
   AllOuts( RootMxr ) = temp_vec(1)
   AllOuts( RootMyr ) = temp_vec(2)
   AllOuts( RootMzr ) = temp_vec(3) 

      ! tip motions:   
   temp_glbp(1) = p%GlbPos(2)
   temp_glbp(2) = p%GlbPos(3)
   temp_glbp(3) = p%GlbPos(1)
   temp_vec(1:3) = MATMUL(p%GlbRot, p%uuN0( (p%node_elem*p%dof_node-5):(p%node_elem*p%dof_node-3),p%elem_total) )
   temp_tip0(1) = temp_vec(2)
   temp_tip0(2) = temp_vec(3)
   temp_tip0(3) = temp_vec(1)
   temp_ini(:) = temp_glbp(:) + temp_tip0(:)
   temp_roott(:) = temp_glbp(:) + u%RootMotion%TranslationDisp(:,1)
   CALL BD_CrvExtractCrv(TRANSPOSE(u%RootMotion%Orientation(1:3,1:3,1)),temp_vec,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL BD_CrvCompose(temp_cc,temp_vec,temp_glb,2,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL BD_CrvMatrixR(temp_cc,temp_R,ErrStat2,ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   temp_vec(:) = MATMUL(temp_R,temp_tip0)
   temp_cur(:) = temp_roott(:) + temp_vec(:)
   temp_vec(:) = y%BldMotion%TranslationDisp(1:3,p%node_elem*p%elem_total) - &
                 (temp_cur(:) - temp_ini(:))
   temp_vec(:) = MATMUL(u%RootMotion%Orientation(1:3,1:3,1),temp_vec)
   AllOuts( TipTDxr ) = temp_vec(1)
   AllOuts( TipTDyr ) = temp_vec(2)
   AllOuts( TipTDzr ) = temp_vec(3)
   !
   !AllOuts( TipRDxr ) =
   !AllOuts( TipRDyr ) =
   !AllOuts( TipRDzr ) =
   !
   !AllOuts( TipTVXg ) =
   !AllOuts( TipTVYg ) =
   !AllOuts( TipTVZg ) =
   !
   !AllOuts( TipRVXg ) =
   !AllOuts( TipRVYg ) =
   !AllOuts( TipRVZg ) =
   !
   !AllOuts( TipTAXg ) =
   !AllOuts( TipTAYg ) =
   !AllOuts( TipTAZg ) =
   !
   !AllOuts( TipRAXg ) =
   !AllOuts( TipRAYg ) =
   !AllOuts( TipRAZg ) =


      ! outputs on the nodes
   do beta=1,p%NNodeOuts
         
      j=p%OutNd(beta)
                           
      !AllOuts( NFl( beta,1 ) ) =
      !AllOuts( NFl( beta,2 ) ) =
      !AllOuts( NFl( beta,3 ) ) =
      !
      !AllOuts( NMl( beta,1 ) ) =
      !AllOuts( NMl( beta,2 ) ) =
      !AllOuts( NMl( beta,3 ) ) =
      !
      AllOuts( NTDr( beta,1 ) ) = y%BldMotion%TranslationDisp(1,j)
      AllOuts( NTDr( beta,2 ) ) = y%BldMotion%TranslationDisp(2,j)
      AllOuts( NTDr( beta,3 ) ) = y%BldMotion%TranslationDisp(3,j)
      !
      !AllOuts( NRDr( beta,1 ) ) =
      !AllOuts( NRDr( beta,2 ) ) =
      !AllOuts( NRDr( beta,3 ) ) =
            
      AllOuts( NTVg( beta,1 ) ) = y%BldMotion%TranslationVel(1,j)
      AllOuts( NTVg( beta,2 ) ) = y%BldMotion%TranslationVel(2,j)
      AllOuts( NTVg( beta,3 ) ) = y%BldMotion%TranslationVel(3,j)
         
      AllOuts( NRVg( beta,1 ) ) = y%BldMotion%RotationVel(1,j)*R2D
      AllOuts( NRVg( beta,2 ) ) = y%BldMotion%RotationVel(2,j)*R2D
      AllOuts( NRVg( beta,3 ) ) = y%BldMotion%RotationVel(3,j)*R2D
    
      AllOuts( NTAg( beta,1 ) ) = y%BldMotion%TranslationAcc(1,j)
      AllOuts( NTAg( beta,2 ) ) = y%BldMotion%TranslationAcc(2,j)
      AllOuts( NTAg( beta,3 ) ) = y%BldMotion%TranslationAcc(3,j)
         
      AllOuts( NRAg( beta,1 ) ) = y%BldMotion%RotationAcc(1,j)*R2D
      AllOuts( NRAg( beta,2 ) ) = y%BldMotion%RotationAcc(2,j)*R2D
      AllOuts( NRAg( beta,3 ) ) = y%BldMotion%RotationAcc(3,j)*R2D
            
      !
      !AllOuts( NPFl( beta,1 ) ) = 
      !AllOuts( NPFl( beta,2 ) ) = 
      !AllOuts( NPFl( beta,3 ) ) =     
      !
      !AllOuts( NPMl( beta,1 ) ) = 
      !AllOuts( NPMl( beta,2 ) ) = 
      !AllOuts( NPMl( beta,3 ) ) = 
      !
      !AllOuts( NDFl( beta,1 ) ) = 
      !AllOuts( NDFl( beta,2 ) ) = 
      !AllOuts( NDFl( beta,3 ) ) =  
      !
      !AllOuts( NDMl( beta,1 ) ) = 
      !AllOuts( NDMl( beta,2 ) ) = 
      !AllOuts( NDMl( beta,3 ) ) = 
      
   end do ! nodes
         
END SUBROUTINE Calc_WriteOutput
!----------------------------------------------------------------------------------------------------------------------------------

END MODULE BeamDyn_IO
