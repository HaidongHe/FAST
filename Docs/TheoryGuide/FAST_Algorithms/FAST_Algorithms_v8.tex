%----------------------------------------------------------
%

\documentclass[10pt,letterpaper,oneside,notitlepage]{article}
%\documentclass{report}%
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{nomencl}
\usepackage{amsmath}%
%\usepackage{amsfonts}%
%\usepackage{amssymb}%
%\usepackage{graphicx}
%----------------------------------------------------------
\makenomenclature
%\theoremstyle{plain}
%\newtheorem{acknowledgement}{Acknowledgement}
%\newtheorem{definition}{Definition}
%\newtheorem{remark}{Remark}
%\numberwithin{equation}{section}
%-----------------------------------------------------------
\begin{document}
\title{Algorithms in FAST v8}
\author{Bonnie Jonkman}
%\begin{abstract}
%This document is used to describe the algorithms implemented in FAST v8.
%\end{abstract}
\maketitle

%\tableofcontents

\section{Definitions and Nomenclature}


\begin{table}[h]
	\centering
		\begin{tabular}{c|c|c}
		\textbf{Module} & \textbf{Abbreviation} & \textbf{Abbreviation}\\
		\textbf{Name}   & \textbf{in Module}    & \textbf{in this Document}\\
		\hline 
		ElastoDyn       & ED                    & ED        \\
		AeroDyn         & AD                    & AD        \\
		ServoDyn        & SrvD                  & SrvD      \\
		SubDyn          & SD                    & SD        \\
		HydroDyn        & HydroDyn              & HD        \\
		MAP             & MAP                   & MAP       \\
		FEAMooring      & FEAM                  & FEAM      \\
		InflowWind      & IfW                   & IfW       \\   
		IceFloe         & IceFloe               & IceF      \\   
		IceDyn          & ID                    & IceD      \\   
		\end{tabular}
	\caption{Abbreviations for modules in FAST v8}
	\label{tab:Abbrev}
\end{table}


\nomenclature{$u\_ED$}{$ElastoDyn$ inputs}
\nomenclature{$u\_AD$}{$AeroDyn$ inputs}
\printnomenclature

\section{Initializations}


\pagebreak %break here for now so that it doesn't look so strange
\section{Input-Output Relationships}
\subsection {Input-Output Solves (Option 2 Before 1)}
This algorithm documents the procedure for the Input-Output solves in FAST, assuming
all modules are in use. If an individual module is not in use during a particular
simulation, the calls to that module's subroutines are omitted and the module's 
inputs and outputs are neither set nor used.

%\begin{algorithm}[ht]
%\caption{Input-Output Solves (Option 2 Before 1)}
%\label{IOSolves21}
\begin{algorithmic}[1]
\Procedure{CalcOutputs\_And\_SolveForInputs}{\null}
\State $\mathit{y\_ED} \gets \Call{ED\_CalcOutput}{\mathit{p\_ED},\mathit{u\_ED},\mathit{x\_ED},\mathit{xd\_ED},\mathit{z\_ED}}$

\State
	\State $\mathit{u\_AD} \gets \Call{TransferOutputsToInputs}{\mathit{y\_ED}}$
	\State $\mathit{y\_AD} \gets \Call{AD\_CalcOutput}{\mathit{p\_AD},\mathit{u\_AD},\mathit{x\_AD},\mathit{xd\_AD},\mathit{z\_AD}}$

\State
	\State $\mathit{u\_SrvD} \gets \Call{TransferOutputsToInputs}{\mathit{y\_ED},\mathit{y\_AD}}$
	\State $\mathit{y\_SrvD} \gets \Call{SrvD\_CalcOutput}{}( \!
				\begin{aligned}[t]
				                      & \mathit{p\_SrvD},\mathit{u\_SrvD}, \\
	                            & \mathit{x\_SrvD},\mathit{xd\_SrvD},\mathit{z\_SrvD}) \\
				\end{aligned}$

\State
	\State $\mathit{u\_ED}($not platform reference point$) \gets \Call{TransferOutputsToInputs}{y\_SrvD,y\_AD}$ %\Comment{sets all but platform reference point inputs}

	\State $\mathit{u\_HD}   \gets \Call{TransferMeshMotions}{\mathit{y\_ED}}$
	\State $\mathit{u\_SD}   \gets \Call{TransferMeshMotions}{\mathit{y\_ED}}$
	\State $\mathit{u\_MAP}  \gets \Call{TransferMeshMotions}{\mathit{y\_ED}}$
	\State $\mathit{u\_FEAM} \gets \Call{TransferMeshMotions}{\mathit{y\_ED}}$

\State
\State \Call{ED\_HD\_SD\_Mooring\_Ice\_InputOutputSolve}{\null}
\State
\textit{
\State If $AeroDyn$ or $ServoDyn$ had states to update, we should do this:
\State\hspace{\algorithmicindent} $\mathit{u\_AD} \gets \Call{TransferOutputsToInputs}{\mathit{y\_ED}}$
\State\hspace{\algorithmicindent} $\mathit{u\_SrvD} \gets \Call{TransferOutputsToInputs}{\mathit{y\_ED},\mathit{y\_AD}}$
\State However, they don't so we'll omit these steps for efficiency.
}
\EndProcedure
\end{algorithmic}
%\end{algorithm}

Note that inputs to $ElastoDyn$ before calling CalcOutput() in the first step are not set in CalcOutputs\_And\_SolveForInputs(). 
Instead, the $ElastoDyn$ inputs are set depending on where CalcOutputs\_And\_SolveForInputs() is called:
\begin{itemize}[noitemsep] %i don't like the double spaces between bulleted items.
	\item At time 0, the inputs are the initial guess from $ElastoDyn$;
	\item On the prediction step, the inputs are extrapolated values from the time history of ElastoDyn inputs;
	\item On the first correction step, the inputs are the values calculated in the prediction step;
	\item On subsequent correction steps, the inputs are the values calculated in the previous correction step.
\end{itemize}


%\pagebreak %break here for now so that it doesn't look so strange
%\subsection {Input-Output Solve for $HydroDyn$, $SubDyn$, $MAP$, \\ 
%       $FEAMooring$, $IceFloe$, and the Platform Reference Point Mesh in $ElastoDyn$}
\subsection {Input-Output Solve for \textit{HydroDyn}, \textit{SubDyn}, \textit{MAP}, 
       \textit{FEAMooring}, \textit{IceFloe}, and the Platform Reference Point Mesh in \textit{ElastoDyn}}

This procedure implements Solve Option 1 for the accelerations and loads in
$HydroDyn$, $SubDyn$, $MAP$, $FEAMooring$, and $ElastoDyn$ (at its platform reference point mesh). 
The other input-output relationships for these modules are solved using Solve Option 2.

%\begin{algorithm}[ht]
%\caption{Input-Output Solve for $HydroDyn$, $SubDyn$, $MAP$, $FEAMooring$, and the Platform Reference Point Mesh in $ElastoDyn$}
%\label{IOSolves_PlatformRef}
\begin{algorithmic}[1]

\Procedure{ED\_HD\_SD\_Mooring\_Ice\_InputOutputSolve}{\null}
	\State
	\State $\mathit{y\_MAP}  \gets \Call{CalcOutput}{\mathit{p\_MAP},\mathit{u\_MAP},\mathit{x\_MAP},\mathit{xd\_MAP},\mathit{z\_MAP}}$ 
	\State $\mathit{y\_FEAM} \gets \Call{CalcOutput}{\mathit{p\_FEAM},\mathit{u\_FEAM},\mathit{x\_FEAM},\mathit{xd\_FEAM},\mathit{z\_FEAM}}$
	\State $\mathit{y\_IceF} \gets \Call{CalcOutput}{\mathit{p\_IceF},\mathit{u\_IceF},\mathit{x\_IceF},\mathit{xd\_IceF},\mathit{z\_IceF}}$
	\State $\mathit{y\_IceD(:)} \gets \Call{CalcOutput}{\mathit{p\_IceD},\mathit{u\_IceD(:)},\mathit{x\_IceD(:)},\mathit{xd\_IceD(:)},\mathit{z\_IceD(:)}}$
	\State
	\State\Comment{Form $u$ vector using loads and accelerations from $\mathit{u\_HD}$, $\mathit{u\_SD}$, and platform reference input from $\mathit{u\_ED}$}
	\State
	\State $u \gets \Call{u\_vec}{\mathit{u\_HD},\mathit{u\_SD},\mathit{u\_ED}}$
	\State $k \gets 0$
	\Loop\Comment{Solve for loads and accelerations (direct feed-through terms)}
		\State $y\_ED \gets \Call{ED\_CalcOutput}{\mathit{p\_ED},\mathit{u\_ED},\mathit{x\_ED},\mathit{xd\_ED},\mathit{z\_ED}}$
		\State $y\_SD \gets \Call{SD\_CalcOutput}{\mathit{p\_SD},\mathit{u\_SD},\mathit{x\_SD},\mathit{xd\_SD},\mathit{z\_SD}}$
		\State $y\_HD \gets \Call{HD\_CalcOutput}{\mathit{p\_HD},\mathit{u\_HD},\mathit{x\_HD},\mathit{xd\_HD},\mathit{z\_HD}}$
	
		\If{ $k \geq k\_max$}
			\State exit loop
		\EndIf
		
		\State$\mathit{u\_MAP\_tmp} \gets \Call{TransferMeshMotions}{y\_ED}$
		\State$\mathit{u\_FEAM\_tmp} \gets \Call{TransferMeshMotions}{y\_ED}$
		\State$\mathit{u\_IceF\_tmp} \gets \Call{TransferMeshMotions}{y\_SD}$
		\State$\mathit{u\_IceD\_tmp(:)} \gets \Call{TransferMeshMotions}{y\_SD}$
		\State$\mathit{u\_HD\_tmp} \gets \Call{TransferMeshMotions}{y\_ED,y\_SD}$
		\State$\mathit{u\_SD\_tmp} \gets \!
				\begin{aligned}[t]
           & \Call{TransferMeshMotions}{\mathit{y\_ED}}  \\
					 & \cup \Call{TransferMeshLoads}{}(\!
					    \begin{aligned}[t] 
							   & \mathit{y\_SD}, \\
							   & \mathit{y\_HD},\mathit{u\_HD\_tmp}, \\
					       & \mathit{y\_IceF},\mathit{u\_IceF\_tmp}) \\
					       & \mathit{y\_IceD(:)},\mathit{u\_IceD\_tmp(:)}) \\
							\end{aligned}
			\end{aligned}$
		\State$\mathit{u\_ED\_tmp} \gets \Call{TransferMeshLoads}{}( \!
				     \begin{aligned}[t]   & \mathit{y\_ED}, \\
																  & \mathit{y\_HD},  \mathit{u\_HD\_tmp},  \\
																  & \mathit{y\_SD},  \mathit{u\_SD\_tmp},  \\  
																	& \mathit{y\_MAP}, \mathit{u\_MAP\_tmp}, \\ 
																	& \mathit{y\_FEAM},\mathit{u\_FEAM\_tmp} )
							\end{aligned}$

		\State
		\State$\mathit{U\_Residual} \gets u - \Call{u\_vec}{\mathit{u\_HD\_tmp},\mathit{u\_SD\_tmp},\mathit{u\_ED\_tmp}}$
		\State
		
		\If{ last Jacobian was calculated at least $\mathit{DT\_UJac}$ seconds ago }
			\State Calculate $\frac{\partial U}{\partial u}$
		\EndIf
		
		%\textit{
		%\State Perturb each input in $u$
		%\State Call $\Call{CalcOutput}{p,u,x,xd,z}$ for each module
		%\State Transfer perturbed outputs to inputs
		%\State Form new $u$
		%\State Compare new $u$ with $U\_Residual$
		%\State}

		\State Solve  $\frac{\partial U}{\partial u} \Delta u = - \mathit{U\_Residual}$ for $\Delta u$

		\State    
		\If{$\lVert \Delta u \rVert_2 < $ tolerance } \Comment{To be implemented later}
			\State exit loop
		\EndIf
		\State
		\State $u \gets u + \Delta u$
		\State Transfer $u$ to $\mathit{u\_HD}$, $\mathit{u\_SD}$, and $\mathit{u\_ED}$\Comment{loads and accelerations only}
		\State $k=k+1$
		
	\EndLoop	
	
	\State\Comment{Transfer non-acceleration fields to motion input meshes}
	\State 
	
	\State$\mathit{u\_HD}($not accelerations$) \gets \Call{TransferMeshMotions}{\mathit{y\_ED},\mathit{y\_SD}}$
	\State$\mathit{u\_SD}($not accelerations$) \gets \Call{TransferMeshMotions}{\mathit{y\_ED}}$
  \State 
	\State $\mathit{u\_MAP}  \gets \Call{TransferMeshMotions}{\mathit{y\_ED}}$
	\State $\mathit{u\_FEAM} \gets \Call{TransferMeshMotions}{\mathit{y\_ED}}$
	\State $\mathit{u\_IceF} \gets \Call{TransferMeshMotions}{\mathit{y\_SD}}$
	\State $\mathit{u\_IceD(:)} \gets \Call{TransferMeshMotions}{\mathit{y\_SD}}$
			
\EndProcedure

\end{algorithmic}
%\end{algorithm}

\subsection {Implementation of line2-to-line2 loads mapping}
The inverse-lumping of loads is computed by a block matrix solve for the distributed forces and moments, 
using the following equation:

\begin{equation}
\label{EqLump}
	\begin{bmatrix}
	F^{DL} \\
	M^{DL} \\
	\end{bmatrix}
=
	\begin{bmatrix}
		A & 0 \\
		B & A \\	
	\end{bmatrix}
	\begin{bmatrix}
	F^{D} \\
	M^{D} \\
	\end{bmatrix}
\end{equation}

Because the forces do not depend on the moments, we first solve for the distributed forces, $F^D$:
\begin{equation}
\label{EqLumpF}
	\begin{bmatrix}	F^{DL} \\	\end{bmatrix}
=
	\left[		A    \right]
	\left[	F^{D}  \right]
\end{equation}

We then use the known values to solve for the distributed moments, $M^D$:
\begin{equation}
\label{EqLumpM1}
	\left[	M^{DL} \right]
=
	\begin{bmatrix} B & A \\	\end{bmatrix}
	\begin{bmatrix}
	F^{D} \\
	M^{D} \\
	\end{bmatrix}
= \left[	B \right] \left[	F^D \right] + \left[	A \right] \left[	M^D \right] 
\end{equation}
or
\begin{equation}
\label{EqLumpM2}
\left[	M^{DL} \right] - \left[	B \right] \left[	F^D \right] = \left[	A \right] \left[	M^D \right]
\end{equation}
Rather than store the matrix $B$, we directly perform the cross products that the matrix $B$ represents.
This makes the left-hand side of Equation \ref{EqLumpM2} known, leaving us with one matrix solve. This 
solve uses the same matrix $A$ used to obtain the distributed forces in Equation \ref{EqLumpF}; $A$ depends 
only on element connectivity \textbf{\textit{(bjj: check that this is true)}}. We use 
the $LU$ factorization of matrix $A$ so that the second solve does not introduce much additional overhead.

\end{document}
